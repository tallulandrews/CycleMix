---
title: "CycleMix: Cell Cycle Assignment for scRNAseq data"
author: "Tallulah Andrews"
output: 
  BiocStyle::html_document
package: CycleMix
vignette: >
  %\VignetteIndexEntry{CycleMix: Cell Cycle Assignment for scRNAseq data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
```

```{r setup}
set.seed(1973)
library("CycleMix")
library("SingleCellExperiment")
library("scater")
```
# Introduction

Droplet-based single-cell RNA sequencing (scRNAseq) enables the assaying of tens of thousands to millions of cells. One important feature of those cells is often which of those cells are actively proliferating and which are not. In addition, we may want to remove the transcriptional signature of this proliferation from our scRNAseq to avoid cells being clustered together simply because they are within the same cell-cycle stage.

This package implements a method for robustly classifying single cells by their cell-cycle phase and flexibly regressing out the transcriptional differences between any combination of phases specified by the user. This enables both complete regression of transcriptional differences related to the cell-cycle or simply regressing out differences between different phases of the cellcycle while preserving differences between proliferating and non-proliferating cells.

# Input Data 

CycleMix requires a matrix or object containing single-cell or single-nucleus RNAseq data. Single-cell spatial transcriptomics data can also be used. As well as a table of marker genes for each cell state to classify cells into - we have provided tables for the cell-cycle phases in this package.

CycleMix can use a SingleCellExperiment object, a Seurat object, or a matrix or sparse matrix as input. We have provided a SCE and Seurat object for this tutorial. Data must be normalized prior to using CycleMix, this can be accomplished using sctransform, vst, scran or any other normalization approach. Batch-effect corrected counts are also compatible with CycleMix.


## SingleCellExperiment
When using a SingleCellExperiment object, CycleMix will look for a column in the rowData of the object for the names of the genes. Here we have a column called "feature_symbol" to use.

```{r}
head(rowData(Ex))
```

You should also have a log-transformed normalized expression matrix in the SingleCellExperiment object, by default CycleMix uses the matrix named "logcounts", but any matrix can be specified.:

```{r}
names(assays(Ex))
```

See the SingleCellExperiment, scater, or scran packages for details on creating and normalizing data in SingleCellExperiment objects.

## Seurat Object
CycleMix is compatible with Seurat(v5). When using CycleMix with multiple samples of scRNAseq data in Seurat, you must use `JoinLayers()` to merge the samples into a single assay matrix prior to using CycleMix. 
```{r}
sample1 <- Seurat::CreateSeuratObject(counts=Ex2.2$counts, meta.data=Ex2.2$meta)
sample2 <- Seurat::CreateSeuratObject(counts=Ex2.2$counts, meta.data=Ex2.2$meta)
all_data <- merge(sample1, sample2, add.cell.ids=c("sample1", "sample2"))

all_data_joined <- SeuratObject::JoinLayers(all_data)
all_data_joined <- Seurat::NormalizeData(all_data_joined)
```

Alternatively, using SCTransform on the entire object will automatically join the layers together.
```{r}
all_data_sct <- Seurat::SCTransform(all_data)
```

## Normalized / Batch Corrected expression matrix
For maximum flexibility, CycleMix is also compatible with data provided as a matrix or Matrix from any type of normalization or batch effect correction. Here we will extract the Pearson residuals from sctransform as an example.

```{r}
corrected_mat <- Seurat::GetAssayData(all_data_sct, assay="SCT", layer="scale.data")
```

## Marker Matrix
The marker matrix must have 3 columns: 
- Gene : Gene names that match those in your matrix / object
- Stage : Which cell-cycle stage or other cell-state the marker is associated with.
- Dir : a quantitative score indicating the strength and/or directions of the association. Positive values are genes upregulated in the stage, negative values are genes down regulated in the stage.

```{r}
head(MGeneSets$Cyclone)
```
The "Dir" column is used to weight the gene expression we have simplified this to positive (1) and negative (-1) markers, but any numeric value can be used, for instance fold change.

We have provided tables with gene symbols for published cell-cycle marker gene sets. You can find the details for these gene sets using:

```{r eval=FALSE}
?HGeneSets
```
### Converting & Combining GeneSets
We can convert human cell-cycle genes to mouse orthologs using biomaRt with our provided wrappers. For instance if we want to use the quiescence markers in mouse we would convert them as so:

```{r eval=FALSE}
require("biomaRt") 
map <- CycleMix::downloadEnsemblData()
mouse_g0 <- HGeneSets$Quiesc
mouse_g0$Gene <- CycleMix::mapGeneNames(map, mouse_g0$Gene, in.name="symbol", in.org="Hsap", out.name="symbol", out.org="Mmus")
mouse_g0 <- mouse_g0[mouse_g0$Gene != "",]
```

Gene sets can also be combined together easily:

```{r, eval=FALSE}
mouse_CC <- rbind(mouse_g0, MGeneSets$Cyclone)
```

# Assigning Cells

We can now assign cell-cycle stages to our cells. For our example data we know all the cells are cycling thus won't include the quiescence markers.


## SingleCellExperiment Object
```{r}
output <- CycleMix::classifyCells(Ex, MGeneSets$Cyclone, symbol_column="feature_symbol") 
print(summary(factor(output$phase)))
```
Our example data comes from staged cells so we can compare our assignments to the ground truth:

```{r}
table(factor(output$phase), Ex$cell_type1)
```

We can also examine the gaussian mixture model fit to each cell-cycle stage:
```{r mixture-plot, dev='png', out.width="4in", out.height="4in"}
plotMixture(output$fit[["G2M"]], BIC=TRUE)
```
The plot on the left shows the 6 different models considered : mixtures of 1-3 gaussian distributions with equal (E) or different (V) variances. The BIC criterion was used to select the optimal model. The plot on the right shows the distribution of expression scores across all cells. The curves of the fitted distributions are plotted on top. The threshold for assigning cells to the stage (if applicable) is indicated with the red dotted line.

## Seurat Object
CycleMix is also compatible with Seurat(v5), and will automatically extract the appropriate data, but we must first identify the appropriat assay
```{r}
require(Seurat)
require(SingleCellExperiment)
# Using joined samples:
output1 <- CycleMix::classifyCells(all_data_joined, HGeneSets$Tirosh, expr_name="RNA")
# Using SCT normalized samples:
output2 <- CycleMix::classifyCells(all_data_sct, HGeneSets$Tirosh, expr_name="SCT")
```
CycleMix automatically uses the "data" layer of the selected assay, if you wish to use the Pearson residuals from SCT instead you would extract the matrix and run like so:

```{r}
corrected_mat <- Seurat::GetAssayData(all_data_sct, assay="SCT", layer="scale.data")
output3 <- CycleMix::classifyCells(corrected_mat, HGeneSets$Tirosh)
```
Very similar classifications are obtained from regardless of which of these options we use for this dataset:

```{r}
table(output1$phase, output2$phase)
table(output2$phase, output3$phase)
```

We can then add the phase information to the Seurat Object.

```{r}
all_data_sct@meta.data$Phase <- output2$phase
all_data_sct@meta.data$G1S_score <- output2$scores[,"G1S"]
all_data_sct@meta.data$G2M_score <- output2$scores[,"G2M"]
```

## matrix / Sparse Matrix
For compatibility with other object types, one can run directly on a sparse matrix, note that the matrix should be fully normalized, and batch-effect corrected (if applicable) prior to running CycleMix.
```{r}
sparse_mat <- logcounts(Ex)
rownames(sparse_mat) <- rowData(Ex)[,1]
output <- classifyCells(sparse_mat, MGeneSets$Cyclone, symbol_column=NULL)
```

# CellCycle Regression
Once we have classified cells by cell-cycle phase, we can correct the expression matrix to remove differences between any set of phases. In many cases, we would like to remove differences between G1S and G2M cells without removing differences between cycling and non-cycling cells because a specific cell-type of interest are those that are cycling. This can be done as below.

To correct the expression matrix, we must provide the specific matrix we would like corrected, the output from assigning phases above, as well as whether to regress using discrete phase labels or to regress the quantitative scores. 

We provide many parameters to adjust this correction for each type of expression values. For batch-effect corrected or other regression residuals (such as the Pearson residuals from sctransform) we need to specify both that these are normalized values, so our corrected values do not need to be integers, and that the expression values are allowed to be negative.

```{r}
orig_pearson <- Seurat::GetAssayData(all_data_sct, assay="SCT", layer="scale.data")
corrected_pearson <- regressCyclePartial(orig_pearson, output3, method="phase", phases=c("G1S", "G2M"), allow_negative=TRUE, type="norm") # correct G2M to match G1S cells
```
For phase-based regression, the first specified phase is treated as the reference state and each other phase is regressed to match that one. Thus, in this case we only partially regress the cell-cycle so only the cells assigned to G2M have been corrected to match the G1S cells, but both remain distinct from non-cycling cells.

```{r}
G2M_cells <- which(output3$phase == "G2M")
G1S_cells <- which(output3$phase == "G1S")
data.frame(original=orig_pearson[1:5,G2M_cells[1]], corrected=corrected_pearson[1:5,G2M_cells[1]])
data.frame(original=orig_pearson[1:5,G1S_cells[1]], not_corrected=corrected_pearson[1:5,G1S_cells[1]])
```
The corrected values can then be added to our Seurat Object as a new assay, or by replacing the existing pearson residuals:

```{r}
all_data_sct@assays$CC_corrected <- CreateAssayObject(data=corrected_pearson) # create a new assay 
all_data_sct@assays$SCT$scale.data <- corrected_pearson # replace the existing pearson residuals
```

If we were instead using log-normalized expression values, we would specify that they are normalized but that the regressed values should not be negative:

```{r}
lognorm_values <- assay(Ex, "logcounts")
corrected_lognorm <- regressCyclePartial(lognorm_values, output, method="phase", phases=c("S","G2M"), allow_negative=FALSE, type="norm") # Remove differences between S and G2M stages.
```

We can also correct raw counts by using a negative binomial regression model rather than a Gaussian regression model.
```{r}
counts_values <- assay(Ex, "counts")
corrected_counts <- regressCyclePartial(lognorm_values, output, method="phase", phases=c("S","G2M"), allow_negative=FALSE, type="counts") # Remove differences between S and G2M stages.
G2M_cells <- which(output$phase=="G2M")
data.frame(original=counts_values[1:5,G2M_cells[1]], corrected=corrected_counts[1:5,G2M_cells[1]])
```

For very large datasets, the regression model can be estimated from a subset of cells, then applied to all cells.
```{r}
corrected_pearson <- regressCyclePartial(orig_pearson, output3, method="phase", phases=c("G1S", "G2M"), allow_negative=TRUE, type="norm", subsample_cells = 1000) # randomly subsample 1000 cells to fit the regression model to.
````

## Score-based regression
For score-based regression, cells are regressed to the reference state of for the specified score, so one could regress out only the G2M score and leave G1S or regress out both G2M and G1S scores. However, generally G1S and G2M scores are correlated with each other so this approach is much more likely to remove other effects correlated with cellular proliferation than the phase-based regression.

```{r}
corrected_pearson <- regressCyclePartial(orig_pearson, output3, method="scores", phases=c("G2M"), allow_negative=TRUE, type="norm") # Regress out only the G2M score
corrected_pearson <- regressCyclePartial(orig_pearson, output3, method="scores", phases=c("G1S","G2M"), allow_negative=TRUE, type="norm") # Regress out both G1S and G2M score
````

Note that even non-proliferating cells are unlikely to have a G1S/G2M score of perfectly 0, so this regression method will alter the expression values of all cells in the dataset.

## Session information

```{r}
sessionInfo()
```
